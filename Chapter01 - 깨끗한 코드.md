## 목차

- [코드가 존재하리라](#1)
- [나쁜 코드](#2)
- [나쁜 코드로 치르는 대가](#3)
  - [원대한 재설계의 꿈](#3-1)
  - [태도](#3-2)
  - [원초적 난제](#3-3)
  - [깨끗한 코드라는 예술?](#3-4)
  - [깨끗한 코드란?](#3-5)
    - [비야네 스트롭스트룹(Bjarne Stroustrup)](#3-5-1)
    - [그래디 부치(Grady Booch)](#3-5-2)
    - ['큰' 데이브 토마스(Dave Thomas)](#3-5-3)
    - [마이클 페더스(Michael Feathers)](#3-5-4)
    - [론 제프리스(Ron Jeffries)](#3-5-6)
    - [워드 커닝햄(Ward Cunningham)](#3-5-6)
- [우리들 생각](#4)
- [우리는 저자다](#5)
- [보이스카우트 규칙](#6)
- [프리퀄과 원칙](#7)
- [결론](#8)

---

<a name="1"></a>

## 코드가 존재하리라

- 코드를 다루는 책은 구시대적이고, 명세를 기준으로 코드가 자동 생성될 것이라는 생각은 틀렸다.
- 언어의 추상화 수준이 높아지고 특정 응용 분야에 적합한 프로그래밍 언어(Domain Specific Language)가 증가할지라도 코드는 사라지지 않는다.
- 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있지만, 어느 순간에는 정밀한 표현이 필요하다. 즉, 코드는 항상 존재한다.

<a name="2"></a>

## 나쁜 코드

- 80년대 후반 Killer App을 구현한 회사가 망한 이유는 나쁜 코드 때문이었다.
- 다들 일정 맞추기에 급급하여 나쁜 코드들을 방치하고선 '나중에 고쳐야지' 라는 생각을 했던 경험이 있을 것이다. 하지만, 나중은 결코 오지 않는다
  - 르블랑의 법칙(leblanc's Law) - '나중은 결코 오지 않는다'

<a name="3"></a>

## 나쁜 코드로 치르는 대가

- 나쁜 코드가 쌓일수록 팀의 생산성을 떨어진다.

<a name="3-1"></a>

### 원대한 재설계의 꿈

- 재설계를 위해 새로운 팀을 투입해도 쉽지 않다.
- 결론은 처음부터 깨끗한 코드를 짜야한다.
  <a name="3-2"></a>

### 태도

- 좋은 코드를 사수하는 일은 우리 프로그래머들의 책임이다.
  - 갑작스러운 요구사항의 변경

<a name="3-3"></a>

### 원초적 난제

- 더러운 코드는 생산성을 저하시킨다. 그와 동시에 개발자들은 기한을 맞추기 위해 더러운 코드를 짠다. 하지만 더러운 코드를 만들어서는 절대 기한을 맞추지 못한다.
- `최대한 깨끗한 코드를 항상 유지하는 것`이 빨리 가기 위한 단 하나의 방법이다.

<a name="3-4"></a>

### 깨끗한 코드라는 예술?

- 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 아는 것은 아니다.
- 깨끗한 코드를 작성하는 프로그래머는 빈 캔퍼스를 우아한 작품으로 바꿔가는 화가와 같다.
  - '코드 감각'이 있는 프로그래머는 나쁜 모듈을 알아보는 것을 넘어서, 해당 모듈을 좋은 모듈로 개선할 방안을 떠올린다.

<a name="3-5"></a>

### 깨끗한 코드란?

- 아래는 우리 분야에서 아주 유명하고 노련한 프로그래머들의 의견이다.

<a name="3-5-1"></a>

#### 비야네 스트롭스트룹(Bjarne Stroustrup)

- 논리가 간단해야 버그가 숨어들지 못함
- 의존성을 최대한 줄여야 유지보수가 쉬워짐
- 오류는 명백한 전략에 의해 철저히 처리
- 성능을 최적으로 유지해야 다른 사람들이 고치려는 유혹에 빠지지 않음
- `깨끗한 코드는 한 가지를 제대로 함`

<a name="3-5-2"></a>

#### 그래디 부치(Grady Booch)

- 단순하고 직접적
- `잘 쓴 문장처럼 읽힘`
- 설계자의 의도를 숨기지 않음
- 명쾌한 추상화와 단순한 제어문

<a name="3-5-3"></a>

#### '큰' 데이브 토마스(Dave Thomas)

- 작성자가 아닌 사람도 읽기 쉽고 `고치기 쉬움`
- `단위 테스트 케이스`와 `인수 테스트 케이스`가 존재
- 의미있는 이름
- 특정 목적을 달성하는 방법은 하나만 제공
- 의존성은 `최소`, 각 의존성을 명확히 정의
- API는 명확하며 `최소`로 줄임
- 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다 -> `인간이 읽기 좋은 코드 (문학적 프로그래밍)`

<a name="3-5-4"></a>

#### 마이클 페더스(Michael Feathers)

- 깨끗한 코드는 누군가 `주의 깊게` 짰다는 느낌을 줌
  <a name="3-5-5"></a>

#### 론 제프리스(Ron Jeffries)

- 켄트 백이 제안한 단순한 코드 규칙
  - 모든 테스트를 통과한다
  - `중복이 없다`
  - 시스템 내 모든 설계 아이디어를 표현한다
  - 클래스, 메서드, 함수 등을 최대한 줄인다
- 중복을 피해라
- 한 기능만 수행하라
- 제대로 표현하라
- 작게 추상화하라

  <a name="3-5-6"></a>

#### 워드 커닝햄(Ward Cunningham)

- 코드를 읽으며 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드
- 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드

  <a name="4"></a>

## 우리들 생각

- `이 책은 우리 오브젝트 멘토 진영이 생각하는 깨끗한 코드를 설명한다.`
- 우리 생각이 절대적으로 '옳다'라는 단정은 금물이다.

<a name="5"></a>

## 우리는 저자다

- 우리는 새 코드를 짜면서 `끊임없이` 기존 코드를 읽는다.
- 읽기 쉽게 만들면 새 코드를 짜기 쉬워진다.

<a name="6"></a>

## 보이스카우트 규칙

- 잘 짠 코드가 전부가 아니다.
- 시간이 지나도 언제나 깨끗하게 유지해야 한다.
- `캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라`

<a name="7"></a>

## 프리퀄과 원칙

- 이 책은 2002년에 출간된 `Agile Software Development: Principles, Patterns, and Practices` (이하, PPP) 책의 프리퀄이다.

<a name="8"></a>

## 결론

- 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. 단지 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개할 뿐이다.
- 나머지는 독자들에게 달려있다.
  - `"연습해, 연습!"`
